var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { jsx, jsxs, Fragment } from "@builder.io/qwik/jsx-runtime";
import { useSignal, $, isServer, useOn, useOnDocument, SSRStream, SSRRaw, Slot, implicit$FirstArg, component$, useStylesScoped$, useTask$, isBrowser, noSerialize, RenderOnce, SkipRender } from "@builder.io/qwik";
import { createElement, createContext, Component, createRef } from "react";
import { renderToString } from "react-dom/server";
import { createRoot, hydrateRoot } from "react-dom/client";
import { flushSync } from "react-dom";
const SlotCtx = createContext({
  scopeId: ""
});
function main(slotEl, scopeId, RootCmp, props) {
  const newProps = getReactProps(props);
  return mainExactProps(slotEl, scopeId, RootCmp, newProps);
}
function mainExactProps(slotEl, scopeId, RootCmp, props) {
  return createElement(SlotCtx.Provider, {
    value: {
      el: slotEl,
      scopeId,
      attachedEl: void 0
    },
    children: createElement(RootCmp, {
      ...props,
      children: createElement(SlotElement, null)
    })
  });
}
class SlotElement extends Component {
  constructor() {
    super(...arguments);
    __publicField(this, "slotC", createRef());
  }
  shouldComponentUpdate() {
    return false;
  }
  componentDidMount() {
    const slotC = this.slotC.current;
    if (slotC) {
      const { attachedEl, el } = this.context;
      if (el) {
        if (!attachedEl) {
          slotC.appendChild(el);
        } else if (attachedEl !== slotC) {
          throw new Error("already attached");
        }
      }
    }
  }
  render() {
    return createElement("q-slotc", {
      class: this.context.scopeId,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: "<!--SLOT-->"
      },
      ref: this.slotC
    });
  }
}
__publicField(SlotElement, "contextType", SlotCtx);
const getReactProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (!key.startsWith("client:") && !key.startsWith("qwik:") && !key.startsWith(HOST_PREFIX)) {
      const normalizedKey = key.endsWith("$") ? key.slice(0, -1) : key;
      obj[normalizedKey] = props[key];
    }
  });
  return obj;
};
const getHostProps = (props) => {
  const obj = {};
  Object.keys(props).forEach((key) => {
    if (key.startsWith(HOST_PREFIX)) {
      obj[key.slice(HOST_PREFIX.length)] = props[key];
    }
  });
  return obj;
};
const useWakeupSignal = (props, opts = {}) => {
  const signal = useSignal(false);
  const activate = $(() => signal.value = true);
  const clientOnly = !!(props["client:only"] || props["qwik:only"] || opts?.clientOnly);
  const clientVisible = props["client:visible"] || props["qwik:visible"] || opts?.eagerness === "visible";
  const clientIdle = props["client:idle"] || props["qwik:idle"] || opts?.eagerness === "idle";
  const clientLoad = props["client:load"] || props["qwik:load"] || clientOnly || opts?.eagerness === "load";
  const clientHover = props["client:hover"] || props["qwik:hover"] || opts?.eagerness === "hover";
  const clientEvent = props["client:event"] || props["qwik:event"];
  if (isServer) {
    if (clientVisible) {
      useOn("qvisible", activate);
    }
    if (clientIdle) {
      useOnDocument("qidle", activate);
    }
    if (clientLoad) {
      useOnDocument("qinit", activate);
    }
    if (clientHover) {
      useOn("mouseover", activate);
    }
    if (clientEvent) {
      useOn(clientEvent, activate);
    }
    if (opts?.event) {
      useOn(opts?.event, activate);
    }
  }
  return [
    signal,
    clientOnly,
    activate
  ];
};
const HOST_PREFIX = "host:";
async function renderFromServer(Host, reactCmp$, scopeId, props, ref, slotRef, hydrationProps) {
  if (isServer) {
    const Cmp = await reactCmp$.resolve();
    const newProps = getReactProps(props);
    Object.assign(hydrationProps, newProps);
    const html = renderToString(mainExactProps(void 0, scopeId, Cmp, newProps));
    const index = html.indexOf("<!--SLOT-->");
    if (index > 0) {
      const part1 = html.slice(0, index);
      const part2 = html.slice(index + "<!--SLOT-->".length);
      return /* @__PURE__ */ jsx(Host, {
        ref,
        ...getHostProps(props),
        children: /* @__PURE__ */ jsx(SSRStream, {
          children: async function* () {
            yield /* @__PURE__ */ jsx(SSRRaw, {
              data: part1
            });
            yield /* @__PURE__ */ jsx("q-slot", {
              ref: slotRef,
              children: /* @__PURE__ */ jsx(Slot, {})
            });
            yield /* @__PURE__ */ jsx(SSRRaw, {
              data: part2
            });
          }
        })
      });
    }
    return /* @__PURE__ */ jsxs(Fragment, {
      children: [
        /* @__PURE__ */ jsx(Host, {
          ref,
          children: /* @__PURE__ */ jsx(SSRRaw, {
            data: html
          })
        }),
        /* @__PURE__ */ jsx("q-slot", {
          ref: slotRef,
          children: /* @__PURE__ */ jsx(Slot, {})
        })
      ]
    });
  }
}
function qwikifyQrl(reactCmp$, opts) {
  return component$((props) => {
    const { scopeId } = useStylesScoped$(`q-slot{display:none} q-slotc,q-slotc>q-slot{display:contents}`);
    const hostRef = useSignal();
    const slotRef = useSignal();
    const internalState = useSignal();
    const [signal, isClientOnly] = useWakeupSignal(props, opts);
    const hydrationKeys = {};
    const TagName = opts?.tagName ?? "qwik-react";
    useTask$(async ({ track }) => {
      const trackedProps = track(() => ({
        ...props
      }));
      track(signal);
      if (!isBrowser) {
        return;
      }
      if (internalState.value) {
        if (internalState.value.root) {
          internalState.value.root.render(main(slotRef.value, scopeId, internalState.value.cmp, trackedProps));
        }
      } else {
        let root = void 0;
        const Cmp = await reactCmp$.resolve();
        const hostElement = hostRef.value;
        if (hostElement) {
          if (isClientOnly) {
            root = createRoot(hostElement);
          } else {
            root = flushSync(() => {
              return hydrateRoot(hostElement, mainExactProps(slotRef.value, scopeId, Cmp, hydrationKeys));
            });
          }
          if (isClientOnly || signal.value === false) {
            root.render(main(slotRef.value, scopeId, Cmp, trackedProps));
          }
        }
        internalState.value = noSerialize({
          cmp: Cmp,
          root
        });
      }
    });
    useTask$(({ track, cleanup }) => {
      track(signal);
      if (isBrowser) {
        cleanup(() => {
          internalState.value?.root?.unmount();
        });
      }
    });
    if (isServer && !isClientOnly) {
      const jsx$1 = renderFromServer(TagName, reactCmp$, scopeId, props, hostRef, slotRef, hydrationKeys);
      return /* @__PURE__ */ jsx(RenderOnce, {
        children: jsx$1
      }, 2);
    }
    return /* @__PURE__ */ jsxs(RenderOnce, {
      children: [
        /* @__PURE__ */ jsx(TagName, {
          ...getHostProps(props),
          ref: (el) => {
            if (isBrowser) {
              queueMicrotask(() => {
                const internalData = internalState.value;
                if (internalData && !internalData.root) {
                  const root = internalData.root = createRoot(el);
                  root.render(main(slotRef.value, scopeId, internalData.cmp, props));
                }
              });
            } else {
              hostRef.value = el;
            }
          },
          children: SkipRender
        }),
        /* @__PURE__ */ jsx("q-slot", {
          ref: slotRef,
          children: /* @__PURE__ */ jsx(Slot, {})
        })
      ]
    });
  });
}
const qwikify$ = /* @__PURE__ */ implicit$FirstArg(qwikifyQrl);
export {
  qwikify$,
  qwikifyQrl
};
